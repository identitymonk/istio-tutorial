= Simple Route Rules
include::_attributes.adoc[]

Send several requests to the customer ingress and watch their responses:

[source, bash]
https://raw.githubusercontent.com/redhat-canada/istio-tutorial/master/scripts/run.sh
----
./scripts/run.sh  
----

The default Kubernetes/OpenShift behavior is to round-robin load-balance across all available pods behind a single Service. Add another replica of recommendation-v2 Deployment and observe the result:

[source,bash]
----
oc scale --replicas=2 deployment/recommendation-v2 
or
kubectl scale --replicas=2 deployment/recommendation-v2 
----

Now, you will see two requests into the v2 and one for v1.

[source,bash]
----
customer => preference => recommendation v1 from '2819441432-qsp25': 29
customer => preference => recommendation v2 from '99634814-sf4cl': 37
customer => preference => recommendation v2 from '99634814-sf4cl': 38
----

Scale back to a single replica of the recommendation-v2 Deployment

[source,bash]
----
oc scale --replicas=1 deployment/recommendation-v2 
or
kubectl scale --replicas=1 deployment/recommendation-v2 
----

[#istiorouting]
== Changing Istio Routings

[#alltorecommendationv1]
=== All users to recommendation:v1

First create a destination rule: 
[source,bash,subs="+macros,+attributes"]
----
oc create -f https://raw.githubusercontent.com/redhat-canada/istio-tutorial/master/istiofiles/destination-rule-recommendation-v1-v2.yml
----

then create a virtual service:
----
oc create -f 
https://raw.githubusercontent.com/redhat-canada/istio-tutorial/master/istiofiles/virtual-service-recommendation-v1.yml
----

Generate some traffic.
you should only see recommendation v1 being called.

[#alltorecommendationv1]
=== All users to recommendation:v1

Note: "replace" instead of "create" since we are overlaying the previous rule

[source,bash,subs="+macros,+attributes"]
----
istioctl replace -f link:{github-repo}/{istiofiles-dir}/virtual-service-recommendation-v1.yml[istiofiles/virtual-service-recommendation-v1.yml] -n tutorial

istioctl get virtualservice

istioctl get virtualservice -o yaml -n tutorial
----

[#alltorecommendationv1v2]
=== All users to recommendation v1 and v2

By simply removing the rule

[source,bash]
----
istioctl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial
----

and you should see the default behavior of load-balancing between v1 and v2

[source,bash]
----
curl customer-tutorial.$(minishift ip).nip.io
----

[#canarydeploymentrecommendation]
=== Canary deployment: Split traffic between v1 and v2

Canary Deployment scenario: push v2 into the cluster but slowly send end-user traffic to it, if you continue to see success, continue shifting more traffic over time

[source,bash]
----
$ oc get pods -l app=recommendation -n tutorial
or
$ kubectl get pods -l app=recommendation -n tutorial

NAME                                  READY     STATUS    RESTARTS   AGE
recommendation-v1-3719512284-7mlzw   2/2       Running   6          2h
recommendation-v2-2815683430-vn77w   2/2       Running   0          1h
----

Create the `virtualservice` that will send 90% of requests to v1 and 10% to v2

[source,bash,subs="+macros,+attributes"]
----
istioctl create -f link:{github-repo}/{istiofiles-dir}/virtual-service-recommendation-v1_and_v2.yml[istiofiles/virtual-service-recommendation-v1_and_v2.yml] -n tutorial
----

and send in several requests:

[source, bash]
----
./scripts/run.sh
----

In another terminal, change the mixture to be 75/25

[source,bash,subs="+macros,+attributes"]
----
istioctl replace -f link:{github-repo}/{istiofiles-dir}/virtual-service-recommendation-v1_and_v2_75_25.yml[istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml] -n tutorial
----

Clean up

[source,bash]
----
istioctl delete -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial
istioctl delete -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial
----

or you can run:

[source, bash]
----
./scripts/clean.sh
----
